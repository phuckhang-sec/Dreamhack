DES symmetric-key (Mã hóa khóa đối xứng DES): 
- Challenge Link: https://dreamhack.io/wargame/challenges/1118
- Sau khi download và giải nén, ta nhân dược file prob.py -> cat prob.py ta được: 
"""
#!/usr/bin/env python3
from Crypto.Cipher import DES
import signal
import os

if __name__ == "__main__":
    signal.alarm(15)

    with open("flag", "rb") as f:
        flag = f.read()
    
    key = b'Dream_' + os.urandom(4) + b'Hacker' 
    key1 = key[:8]
    key2 = key[8:]
    print("4-byte Brute-forcing is easy. But can you do it in 15 seconds?")
    cipher1 = DES.new(key1, DES.MODE_ECB)
    cipher2 = DES.new(key2, DES.MODE_ECB)
    encrypt = lambda x: cipher2.encrypt(cipher1.encrypt(x))
    decrypt = lambda x: cipher1.decrypt(cipher2.decrypt(x))

    print(f"Hint for you :> {encrypt(b'DreamHack_blocks').hex()}")

    msg = bytes.fromhex(input("Send your encrypted message(hex) > "))
    if decrypt(msg) == b'give_me_the_flag':
        print(flag)
    else:
        print("Nope!")
"""
- Phân tích code: 
 + hàm signal.alarm(15): hàm đếm ngược, nếu sau 15 giây sẽ tự động kết thúc chương trình 
 + key là chuỗi 16 bit gồm: 6 byte đã biết + 4 byte chưa biết (random) + 6 byte đã biết
 + key1 = 8 byte đầu của key (chứa 2 bit chưa biết)
 + key2 = 8 byte sau của key (chứa 2 bit chưa biết)
 + Hàm DES.new(key1, DES.MODE_ECB): tạo cipher1 từ key1, tương tự với cipher2.
 + Vì DES là mật mã khóa đối xứng , nó có đặc tính là cả mã hóa và giải mã đều có thể thực hiện được nếu bạn biết khóa , nhưng không thể thực hiện được nếu bạn không biết khóa. Vì vậy, nếu bạn biết 2 byte chưa biết của key1và key2, bạn có thể mã hóa và giải mã cipher1và cipher2.
 -> Vì hàm mã hóa theo thứ tự cipher1 -> cipher2 nên quá trình giải mã phải theo thứ tự cipher2 -> cipher1.
 MỤC TIÊU: Khôi phục 2 bit của 2 khóa để cho kết quả. Nói cách khác: cipher2.encrypt(cipher1.encrypt(b'DreamHack_blocks')).

- Hướng giải quyết: 
 + Exhaustive search: 1 byte = 8 bit => 32 bit => có tất cả 2^32 khóa và một trong số đó là khóa mà ta cần. 
 + Meet-in-the-middle Attack: Vì cipher2.encrypt(cipher1.encrypt(A)) == B thỏa mãn chìa đúng nên việc thực cipher2.decrypthiện cả hai vế sẽ cho ta phương trình mới: cipher1.encrypt(A) == cipher2.decrypt(B).
   * Do key1, key2 có các giá trị 2 byte chưa biết => có 2^16 = 65536 khả năng xảy ra cho cipher1.encrypt(A) và cipher2.decrypt(B)
   * Để tìm phần tử chung của hai mảng dài 65536, thay vì tính toán65536×65536thời gian của các phép toán với hai vòng lặp for, có nhiều thuật toán nhanh hơn. Chúng tôi sẽ thảo luận về các nguyên tắc này chi tiết hơn trong Exploit Tech: Birthday Paradox , nhưng bạn có thể dễ dàng sử dụng các thuật toán này bằng cách sử dụng Python sethoặc dictcấu trúc dữ liệu.

